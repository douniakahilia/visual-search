\chapter{Introduction} \label{sec:intro}

Large databases of images exist in various fields. Indexing ans searching these using textual descriptors is generally not effective \cite[p.657]{forsyth2012}. Visual search offers an alternative to this, by allowing a user to search an image collection using an image as the query, with the aim being to return images similar to the query. This is achieved by generating and comparing numeric, vector based, image descriptors which can be treated similar to words.

This report presents the implementation of such a system in \gls{matlab}. Several different methodologies will be considered, and their results compared and contrasted.

In order to test the system, the Microsoft Research Cambridge Object Recognition Image Database, version 2.0 will be used. This is a freely available image database which is split into 20 rows, with each row containing similar images \cite{criminisi2004}.

\section{System Design} \label{sec:sys-design}
A common framework was used to apply generate descriptors from all of the images, compare them, and display results. This framework uses a \gls{matlab} function handle to input both the descriptor and distance measure. This method allows the core code-body to be generic, so that in order to run a different test only the external descriptor and/or distance measure functions need to be changed.

A block diagram of the operation of the system is shown in Figure \ref{fig:sys-operation}.

\begin{figure}[ht]
	\centering
	\tikzstyle{generalRect} = [rectangle, rounded corners, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill=black!40]
	\tikzstyle{arrow} = [thick,->,>=stealth]
	\begin{tikzpicture}[node distance=1cm]
		\node (compute) [generalRect] {Compute Descriptors};
		\node (descriptor) [generalRect, fill=white, right = of compute] {Descriptor Function};
		\node (compare) [generalRect, below= of compute] {Compare Descriptors};
		\node (query) [generalRect, fill=white, left = of compare, dashed] {Query Image};
		\node (dist) [generalRect, fill=white, right = of compare] {Distance Measure};
		\node (display) [generalRect, below= of compare, fill=white] {Display Results};
		\node (plotPR) [generalRect, below= of display, fill=white] {\shortstack{Plot Precision-Recall Graph}};
		
		\draw [arrow] (compute) -- (compare);
		\draw [arrow, <->] (compute) -- (descriptor);
		\draw [arrow] (compare) -- (display);
		\draw [arrow, <->] (compare) -- (dist);
		\draw [arrow, dashed] (query) -- (compare);
		\draw [arrow] (display) -- (plotPR);
	\end{tikzpicture}
	\caption{System design}
	\label{fig:sys-operation}
\end{figure}

\subsection{Test Methodology} \label{sec:test-methodology}
In order to test the system, a unit test has been written for all of the descriptor and distance measure functions. Each of these tests complies with \gls{matlab}'s unit testing framework, so can be executed using the \texttt{runtests} command.

\subsubsection{Test pattern generation} \label{sec:test-pattern-gen}
Some tests require test patterns in order to test their functionality correctly. For this purpose a suite of test pattern generation programs was written to create image which contain:
\begin{itemize}
	\item A uniform colour.
	\item A uniform pattern.
	\item A combination of the above.
	\item A grid of several of the above images.
\end{itemize}
These test patterns can be used both internally to the unit tests, as well as to perform system level testing.

\section{Techniques Implemented} \label{sec:techniques-implemented}
This section discusses the visual search techniques implemented, along with the theory of their operation and the difficulties which were encountered whilst implementing them.
\subsection{Global Colour Histogram} \label{sec:color-histogram}
A global colour histogram quantises the RGB space into a series of bins. There are $Q$ bins for each dimension, and therefore $Q^3$ bins for the total image. Each pixel in the image is then sorted into the appropriate bin, and the sum of the bin totals is normalised to 1. This vector histogram, of length $Q^3$, can therefore be used to describe the image.

The implementation of this function was relatively straightforward, since example code for the function had been provided \cite{collomosse2016}. The only modifications made to the code were to explicitly state the histogram bin edges. This was necessary to provide a robust descriptor since the provided code normalised the histogram to the range of the input. Therefore an image containing only values in one area of the RGB space, would appear similar to an image with uniform distribution.

The unit tests for this function consist of generating images of known RGB distribution, calculating the RGB histogram by hand for these images, then comparing that to the output of the function.
\subsection{Texture Histogram} \label{sec:texture-histogram}
Texture is a concept in computer vision, but is difficult to define. Texture loosely corresponds to a repeating pattern of edge characteristics, examples of which would include grass pebbles, and hair \cite[p. 194]{forsyth2012}. Texture is important because it appears to be a strong indicator of object identity.

The texture histogram function is implemented as the concatenation of two functions: an edge orientation function, and a histogram function. The edge orientation function returns a two dimensional array where each element contains a value corresponding to an estimate of the edge orientation at that location. This estimate is in the range $-\pi$ to $+\pi$, but is normalised to $0$ to $1$. Weak edges are set to a normalised value of 0.5, corresponding to \SI{0}{\radian}.

In order to perform the edge detection, and edge angle estimation, the function uses the Sobel operator \cite{sobel2015}. The sobel operator is formed of two kernels which are convoluted with input image in order to perform edge detection in the x and y directions respectively. The kernels are defined in Equation \ref{eq:sobel-kernels}. 

\begin{equation}
	K_x = 
	\begin{bmatrix}
	1 & 0 & -1 \\
	2 & 0 & -2 \\
	1 & 0 & -1 \\
	\end{bmatrix}
	K_y = 
	\begin{bmatrix}
	1 & 2 & 1 \\
	0 & 0 & 0 \\
	-1 & -2 & -1 \\
	\end{bmatrix}
	\label{eq:sobel-kernels}
\end{equation}

The edge magnitude and angle are calculated as described in Equations \ref{eq:sobel-mag} and \ref{eq:sobel-ang} respectively. It should be noted that the operates in these equations apply on an element-by-element basis, not to the array as a whole. In addition, the $K_y$ value is inverted in order to allow the performance to match the \gls{matlab} library function \texttt{imgradient}. This allows for easier testing. The pixels with edge magnitudes above a certain threshold are passed to the histogram generation function.
\begin{equation}
\text{Mag} = \sqrt{{K_x}^2 + {K_y}^2}
\label{eq:sobel-mag}
\end{equation}
\begin{equation}
\theta = \atantwo(-K_y, K_x)
\label{eq:sobel-ang}
\end{equation}

In order to test the edge detection function, the output is compared to the \gls{matlab} function \texttt{imgradient}, for several test images, plus a real image. In addition system level testing has been performed with several test images.
\subsection{Gridding and Concatenation of Features} \label{sec:gridding-concatenation}
Gridding of features allows descriptors to apply be considered locally to parts of an image. The implementation of this is fairly simple in \gls{matlab}. The image can be split using the native array indexing of \gls{matlab} to select a subset of the image array. The descriptor function can then be applied to each of these sub images, and the resultant descriptors concatinated into a matrix.

The gridding functon is tested by feeding a gridded sample image into the function and comparing the output to a manually calculated version of what is expected. A test descriptor function, which returns the image reshaped into a vector array is used to simplify this process.

\subsection{Distance Measures} \label{sec:distance-measures}

In order to calculate the difference between descriptors, the L2 norm is used. This distance measure returns the square root of sum of the squares of the differences between elements of a descriptor, as defined in Equation \ref{eq:l2-norm}, where $d_i$ refers to individual differences between array elements.

\begin{equation}
	\text{Distance} = \sqrt{ \Sigma{ ({d_i}^2)} }
	\label{eq:l2-norm}
\end{equation}

The L2 norm calculation function is tested by comparing the output of the function to manually calculated values for various test vectors.

\chapter{Experimental Results} \label{sec:results}

\section{Global Colour Histogram} \label{sec:global-colour-histogram-results}
The global colour histogram function is implemented as \texttt{H =  vs\_compute\_rgb\_histogram(img, Q)} where \texttt{H} is the descriptor returned, \texttt{img} is the image input, and \texttt{Q} is the quantisation level for each image dimension. The descriptor is therefore of length $Q^3$, as discussed in Section \ref{sec:color-histogram}.

In order to analyse the effect of quantisation level on performance, descriptors have been generated for various values of $Q$, and the performance of each value analysed for each test value. Two test images have been chosen, 9\_23\_s and 13\_1\_s, and their results are displayed in Figures \ref{fig:colour-hist-sheep-graph} and \ref{fig:colour-hist-books-graph} respectively. These images have been chosen because they represent two contrasting examples of what could be presented to the algorithm. Image 9\_23\_s shows a sheep in a field. This image has two strongly dominant colours: the green of the grass, and the cream of the sheep's wool, and very little other colour content in the picture. On the other hand 13\_1\_s shows a collection of differently coloured books on a shelf. This image contains many different colours.

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/9_23_s}
		\subcaption{Query image}
		\label{fig:colour-hist-sheep-img}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/global_colour_hist/9_23_s/pr_2.txt}{Q=2} \prplotadd{data/global_colour_hist/9_23_s/pr_3.txt}{Q=3}
		\prplotadd{data/global_colour_hist/9_23_s/pr_4.txt}{Q=4}
		%\prplotadd{data/global_colour_hist/9_23_s/pr_5.txt}{Q=5}
		\prplotadd{data/global_colour_hist/9_23_s/pr_6.txt}{Q=6}
		%\prplotadd{data/global_colour_hist/9_23_s/pr_7.txt}{Q=7}
		\prplotadd{data/global_colour_hist/9_23_s/pr_8.txt}{Q=8}
		%\prplotadd{data/global_colour_hist/9_23_s/pr_9.txt}{Q=9}
		\prplotadd{data/global_colour_hist/9_23_s/pr_10.txt}{Q=10}
		\prplotclose
		\subcaption{Resultant graph}
		\label{fig:colour-hist-sheep}
	\end{minipage}
	\caption{Global colour histogram results for query image 9\_23\_s}
	\label{fig:colour-hist-sheep-graph}
\end{figure}

The results shown in Figures \ref{fig:colour-hist-sheep-graph} and \ref{fig:colour-hist-books-graph} match expectations suggesting that a very low quantisation value does not deliver good results, because there are not enough bins to differentiate between the images. In addition very high values, such as $Q=10$ do not work well because there is two many possible bins, and as such nominally similar colours will be sorted into different bins, and so will not be considered similar by the distance measure function. Both test images suggest that a quantisation level of $Q=4$, yielding $64$ bins, gives the best result, since the line joining these data points is closest to the top right hand corner.

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/13_1_s}
		\subcaption{Query image}
		\label{fig:colour-hist-books-img}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/global_colour_hist/13_1_s/pr_2.txt}{Q=2} \prplotadd{data/global_colour_hist/13_1_s/pr_3.txt}{Q=3}
		\prplotadd{data/global_colour_hist/13_1_s/pr_4.txt}{Q=4}
		%\prplotadd{data/global_colour_hist/13_1_s/pr_5.txt}{Q=5}
		\prplotadd{data/global_colour_hist/13_1_s/pr_6.txt}{Q=6}
		%\prplotadd{data/global_colour_hist/13_1_s/pr_7.txt}{Q=$}
		\prplotadd{data/global_colour_hist/13_1_s/pr_8.txt}{Q=8}
		%\prplotadd{data/global_colour_hist/13_1_s/pr_9.txt}{Q=9}
		\prplotadd{data/global_colour_hist/13_1_s/pr_10.txt}{Q=10}
		\prplotclose
		\subcaption{Resultant graph}
		\label{fig:colour-hist-books-graph}
	\end{minipage}
	\caption{Global colour histogram results for query image 13\_1\_s}
	\label{fig:colour-hist-books}
\end{figure}

\FloatBarrier
\section{Gridding} \label{sec:gridding-results}
Gridding is implemented as the function \texttt{F = vs\_grid(img, h\_level, v\_level, compute\_function)}, where \texttt{img} is the image input, \texttt{h\_level} is the horizontal quantisation level, \texttt{v\_level} is the vertical quantisation level and \texttt{compute\_function} is the descriptor generation function. This configuration therefore gives us two independent variables, \texttt{h\_level} and \texttt{v\_level}.

However, since most of the images in the dataset have a quantisation level of approximately 1.5:1, it makes sense to set the vertical quantisation level to 1.5 times the horizontal quantisation level. Therefore the overall quantisation level, $Q$ can be defined, where \texttt{h\_level = ceil(1.5*Q)}, and \texttt{v\_level = Q}.

In a similar manner to that of Section \ref{sec:global-colour-histogram-results} the optimum quantisation factor will be determined by computing descriptors for various values of $Q$ and then, using two test images, determining which has best results. For this test, the value of $Q$ for the global colour histogram which prodced the best results ($Q=4$) will be used. The same test images as used in Section \ref{sec:global-colour-histogram-results} have also been maintained in order to allow a performance comparison with the non-gridded image.

The same effect of increasing Quantisation factor as experienced with the global colour histogram is expected. Increasing the value should increase performance up to a maximum, at this point the performance should decrease with increasing quantisation factor. One reason for this is that tighter grids mean that small movements in the object could potentially result in the image being quantised in a very different way, meaning visually similar images would be distant from each other in the quantised space.


\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/9_23_s}
		\subcaption{Query image}
		\label{fig:grid-color-sheep-img}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/gridding/color_hist/9_23_s/pr_1.txt}{Q=1}
		\prplotadd{data/gridding/color_hist/9_23_s/pr_2.txt}{Q=2}
		\prplotadd{data/gridding/color_hist/9_23_s/pr_3.txt}{Q=3}
		\prplotadd{data/gridding/color_hist/9_23_s/pr_4.txt}{Q=4}
		\prplotadd{data/gridding/color_hist/9_23_s/pr_8.txt}{Q=8}
		\prplotadd{data/gridding/color_hist/9_23_s/pr_15.txt}{Q=15}
		\prplotadd{data/global_colour_hist/9_23_s/pr_4.txt}{No grid}

		\prplotclose
		\subcaption{Resultant graph}
		\label{fig:grid-color-sheep-graph}
	\end{minipage}
	\caption{Gridded global colour histogram results for query image 9\_23\_s}
	\label{fig:grid-color-sheep}
\end{figure}


\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/13_1_s}
		\subcaption{Query image}
		\label{fig:grid-color-books-img}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/gridding/color_hist/13_1_s/pr_1.txt}{Q=1}
		\prplotadd{data/gridding/color_hist/13_1_s/pr_2.txt}{Q=2}
		\prplotadd{data/gridding/color_hist/13_1_s/pr_3.txt}{Q=3}
		\prplotadd{data/gridding/color_hist/13_1_s/pr_4.txt}{Q=4}
		\prplotadd{data/gridding/color_hist/13_1_s/pr_8.txt}{Q=8}
		\prplotadd{data/gridding/color_hist/13_1_s/pr_15.txt}{Q=15}
		\prplotadd{data/global_colour_hist/13_1_s/pr_4.txt}{No grid}
		
		\prplotclose
		\subcaption{Resultant graph}
		\label{fig:grid-color-books-graph}
	\end{minipage}
	\caption{Gridded global colour histogram results for query image 13\_1\_s}
	\label{fig:grid-color-books}
\end{figure}

Figures \ref{fig:grid-color-sheep} and \ref{fig:grid-color-books} show the results of the gridding process.

Figure \ref{fig:grid-color-sheep} shows little variation across gridding quantisation levels, this is likely due to the fact that the image has only two dominant colours, so all grids have similar colour histograms. Gridding does in the general case show slight performance improvement with this image however. Notably increasing prevision values for higher quantisation levels.

Figure \ref{fig:grid-color-books} on the other hand shows great variation in the result with grid size. Increasing the grid quantisation level to 2 greatly increases the performance up to a recall of around 0.4, and a grid quantisation level of 1 also increases the performance by a large amount also. In addition to this, much higher quantisation steps, such as 8 and 15 show greatly decreased performance. This is due to reasons mentioned previously.


\FloatBarrier
\section{Texture Histogram} \label{sec:texture-histogram-results}
The edge orientation function is implemented as \texttt{F = vs\_edge\_detect(img, compute\_function, strength)} where \texttt{F} is the descriptor returned, \texttt{img} is the image input, \texttt{compute\_function} is the histogram generation function, and \texttt{strength} is the minimum edge strength to consider (range 0--1). The histogram generation function is \texttt{H = vs\_compute\_histogram(img, Q)} where \texttt{H} is the histogram returned, \texttt{img} is the image input and \texttt{Q} is the quantisation factor. When \texttt{vs\_compute\_histogram} is used as the \texttt{compute\_function} in \texttt{vs\_edge\_detect}, the system can produce an edge orientation histogram, with two independent parameters. These parameters determine the minimum strength edge to consider, as well as the quantisation level of the histogram. These parameters will be referred to as $E$ and $Q$ respectively.

Additionally, since texture is an inherently local feature, the image will be gridded. The descriptor function handle is therefore : \texttt{@(x)vs\_grid(x,3,2, @(x)vs\_edge\_detect(x, @(x)vs\_compute\_histogram(x,Q),E))}. The grid quantisation factor of $Q=2$ is used, since this was determined to be the most effective for gridding the RGB histogram in Section \ref{sec:gridding-results}.

Evaluating the effect of changing both $E$ and $Q$ together is computationally expesive, and the results are hard to visualise, since a 3 axis plot would be required. Therefore the two variables will be evaluated separately.

Initially the effect of changing the histogram quantisation level, $Q$, will be investigated using a constant $E$ of 0. This will leave all edges in the image for the consideration of the histogram

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/9_23_s}
		\subcaption{Query image}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/grid_text_hist/E_0/9_23_s/pr_4.txt}{Q=4}
		\prplotadd{data/grid_text_hist/E_0/9_23_s/pr_8.txt}{Q=8}
		\prplotadd{data/grid_text_hist/E_0/9_23_s/pr_10.txt}{Q=10}
		\prplotadd{data/grid_text_hist/E_0/9_23_s/pr_12.txt}{Q=12}
		\prplotadd{data/grid_text_hist/E_0/9_23_s/pr_15.txt}{Q=16}
		\prplotadd{data/grid_text_hist/E_0/9_23_s/pr_18.txt}{Q=18}
		\prplotadd{data/grid_text_hist/E_0/9_23_s/pr_20.txt}{Q=20}
		\prplotclose
		\subcaption{Resultant graph}
	\end{minipage}
	\caption{Gridded texture histogram results for query image 9\_23\_s, with $E=0$}
	\label{fig:grid-text-sheep}
\end{figure}

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/13_1_s}
		\subcaption{Query image}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/grid_text_hist/E_0/13_1_s/pr_4.txt}{Q=4}
		\prplotadd{data/grid_text_hist/E_0/13_1_s/pr_8.txt}{Q=8}
		\prplotadd{data/grid_text_hist/E_0/13_1_s/pr_10.txt}{Q=10}
		\prplotadd{data/grid_text_hist/E_0/13_1_s/pr_12.txt}{Q=12}
		\prplotadd{data/grid_text_hist/E_0/13_1_s/pr_15.txt}{Q=16}
		\prplotadd{data/grid_text_hist/E_0/13_1_s/pr_18.txt}{Q=18}
		\prplotadd{data/grid_text_hist/E_0/13_1_s/pr_20.txt}{Q=20}
		\prplotclose
		\subcaption{Resultant graph}
	\end{minipage}
	\caption{Gridded texture histogram results for query image 13\_1\_s, with $E=0$}
	\label{fig:grid-text-books}
\end{figure}

Figure \ref{fig:grid-text-sheep} shows that for the sheep image, there is very little difference in performance with quantisation levels greater than approximately 4. Figure \ref{fig:grid-text-books} shows that the books, on the other hand, performance is dependant on quantisation level. Higher quantisation levels continue to improve performance, up to approximately $Q=16$, after this point performance decreases.


\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/9_23_s}
		\subcaption{Query image}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/grid_text_hist/Q_16/9_23_s/pr_0.txt}{E=0}
		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_1.txt}{E=0.1}
		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_2.txt}{E=0.2}
		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_3.txt}{E=0.3}
%		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_4.txt}{E=0.4}
		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_5.txt}{E=0.5}
%		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_6.txt}{E=0.6}
		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_7.txt}{E=0.7}
%		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_8.txt}{E=0.8}
		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_9.txt}{E=0.9}
%		\prplotadd{data/grid_text_hist/Q_16/9_23_s/pr_10.txt}{E=1.0}
		\prplotclose
		\subcaption{Resultant graph}
	\end{minipage}
	\caption{Gridded texture histogram results for query image 9\_23\_s, with $Q=16$}
	\label{fig:grid-text-sheep-q16}
\end{figure}

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/13_1_s}
		\subcaption{Query image}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/grid_text_hist/Q_16/13_1_s/pr_0.txt}{E=0}
		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_1.txt}{E=0.1}
		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_2.txt}{E=0.2}
		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_3.txt}{E=0.3}
%		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_4.txt}{E=0.4}
		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_5.txt}{E=0.5}
%		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_6.txt}{E=0.6}
		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_7.txt}{E=0.7}
%		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_8.txt}{E=0.8}
		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_9.txt}{E=0.9}
%		\prplotadd{data/grid_text_hist/Q_16/13_1_s/pr_10.txt}{E=1.0}
		\prplotclose
		\subcaption{Resultant graph}
	\end{minipage}
	\caption{Gridded texture histogram results for query image 13\_1\_s, with $Q=16$}
	\label{fig:grid-text-books-q16}
\end{figure}

Figures \ref{fig:grid-text-sheep-q16} and \ref{fig:grid-text-books-q16} show the result of varying $E$, whilst keeping $Q$ at a constant value of $16$. The results are interesting. For the bookshelves, increasing $E$ above zero improves performance up to approximately $E=0.3$, however, for the sheep increasing $E$ above $0$ greatly hinders performance. This is likely due to the face that whilst the books have lots of strong edges (at the edges of the books), which will remain with increasing values of $E$, the sheep image likely lacks these strong edges, and so increasing $E$ removes almost all of the relevant edges from the generated descriptor.

\FloatBarrier
\section{Concatenation of Descriptors} \label{sec:conc-desc-results}
Sections \ref{sec:gridding-results} and \ref{sec:texture-histogram-results} demonstrate the effectiveness of gridded colour histogram and texture descriptors. It stands to reason therefore that these descriptors could be combined to produce a descriptor of even greater effectiveness. This is possible in matlab using the native array indexing interface, but it is clearer to use the \texttt{horzcat} function.

A combined descriptor can therefore be invoked using the function handle \texttt{@(x)horzcat( texture\_func(x) .* M, color\_func(x))} where \texttt{texture\_func(x)} and \texttt{color\_func(x)} are function handles to the texture and colour descriptor functions respectively, where their single parameter, \texttt{x} is the input image. The only other parameter in this function is \texttt{M}. \texttt{M} is a multiplier in order to adjust the weighting between the texture and colour descriptors. When \texttt{M} is $1$ the two descriptors are equally weighted, however since the colour descriptor is 4 times as long as the texture descriptor (a 64 bin histogram, vs and 8 bit histogram), it is effectively weighted more highly since there are many more dimensions in which values can be distant. Whilst weighting of $M=4$ should therefore make up for this difference in descriptor length, a different value may provide better results.

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/9_23_s}
		\subcaption{Query image}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/grid_text_hist/Q_16/9_23_s/pr_0.txt}{Texture only}
		\prplotadd{data/gridding/color_hist/9_23_s/pr_2.txt}{Colour only}
		\prplotadd{data/concat/9_23_s/pr_1.txt}{W = 1}
		\prplotadd{data/concat/9_23_s/pr_4.txt}{W = 4}
		\prplotadd{data/concat/9_23_s/pr_10.txt}{W = 10}
		\prplotclose
		\subcaption{Resultant graph}
	\end{minipage}
	\caption{Concatenated descriptor results for query image 9\_23\_s}
	\label{fig:concat-sheep}
\end{figure}

\begin{figure}[ht]
	\begin{minipage}[]{0.3\linewidth}
		\centering
		\includegraphics[width = 0.9\linewidth]{figs/msrc/13_1_s}
		\subcaption{Query image}
	\end{minipage}
	\begin{minipage}[]{0.7\linewidth}
		\centering
		\prplot{data/grid_text_hist/Q_16/13_1_s/pr_0.txt}{Texture only}
		\prplotadd{data/gridding/color_hist/13_1_s/pr_2.txt}{Colour only}
		\prplotadd{data/concat/13_1_s/pr_1.txt}{W = 1}
		\prplotadd{data/concat/13_1_s/pr_4.txt}{W = 4}
		\prplotadd{data/concat/13_1_s/pr_10.txt}{W = 10}
		\prplotclose
		\subcaption{Resultant graph}
	\end{minipage}
	\caption{Concatenated descriptor results for query image 13\_1\_s}
	\label{fig:concat-books}
\end{figure}

Figure \ref{fig:concat-sheep} shows that the concatenated descriptor remains very close to the plot of only the RGB histogram for all values of $W$ plotted. This implies that all of the descriptors are very close in the texture plot, leading to the colour plot dominating the results.

Figure \ref{fig:concat-books} on the other hand shows that the concatenated descriptor does vary between the two plots with differing values of $W$. This implies that both descriptors have a large amount of differentiation. The results show that a value of $W=1$, the results are close to the RGB histogram, but at $W=10$, the results are closer to the edge orientation histogram. A value of $W=4$ provides a compromise between the two as expected. The results are poorer than the RGB histogram only for this particular query image, but this is unlikely to hold true for all query images since some images will likely be described by colour well, and others by texture well.

\chapter{Conclusion} \label{sec:conclusion}
